%Hauptdokumentation der Lösung
\NeedsTeXFormat{LaTeX2e}

\documentclass[a4paper,oneside,abstract,numbers=noenddot]{scrreprt}
\usepackage{pdfpages}
\usepackage{comment}
\usepackage{framed}
\usepackage{smartdiagram}
%\usepackage{amsmath}					%Mathematische Umgebungen
%\usepackage{amsthm}
%\usepackage{siunitx}					%SI Einheiten
\graphicspath{{images/}}
\usepackage{german}
\usepackage{mwe}
\usepackage{subfigure}

\usepackage[utf8]{inputenc}


\title{\titel}
\author{\autorA  \and \AutorB \and \AutorC \and \AutorD \and \AutorE \and \AutorF}
\date{\datum}


\begin{document}


\chapter{Software} \label{sec:Konzept} 

\section{Programmablauf}
In diesem Kapitel wird der Ablauf der Software anhand eines spezifischen Beispieles (use-case) aufgezeigt. Dies soll die Interaktion der verschiedenen Klassen und den Datenfluss veranschaulichen.\\
\\
\subsection{Programmstart}
Beim Programmstart wird die Methode \textit{main()} in der Klasse \textit{EzRLC} aufgerufen. Darin werden \textit{Model}, \textit{View} und \textit{Controller} erstellt, miteinander verbunden, und die \textit{View} angezeigt. Danach geschieht in der \textit{main()} Methode nichts mehr. Die \textit{View} erstellt das \textit{NavPanel} und das \textit{WorkPanel}. Das \textit{WorkPanel} wird standardmässig mit dem \textit{IGAssistPanel} gefüllt, welches später einen ersten Überblick über das eingelesene Datenfile zeigt. \\
\\
\subsection{Datenfile einlesen}
Die erste Aktion vom Benutzer ist das Einlesen eines Datenfiles. Dies geschieht über den Button "{}Load File..."{}. In der Methode \textit{actionPerformed()} der Klasse \textit{NavPanel} wird der \textit{FileChooser} aufgerufen. In dem \textit{FileChooser} kann der Benutzer ein Datenfile auswählen. Nach dem Betätigen der "{}OK"{} Taste wird im \textit{Controller} die Methode \textit{loadFile()} aufgerufen. Sie leitet diesen befehl weiter an das \textit{Model} welches eine neue Instanz der Klasse \textit{RFData} erstellt. Mit dem Aufruf der Methode \textit{parse()} in \textit{RFData} wird das Datenfile eingelesen und die Daten in \textit{Complex}-Arrays abgespeichert. Danach wird wiederum im \textit{Controller} über die Methode \textit{buildIGAssistDataSet()} in der Klasse \textit{IGAssistPanel} die Methode \textit{createDatasets} aufgerufen. Sie erstellt alle \textit{DataSet}s (durch Aufrufe der Methode \textit{createDataset()} im \textit{Controller}) welche danach in den \textit{RectangularPlot}s des \textit{IGAssistPanel} dargestellt werden. Durch einen Aufruf von \textit{manualNotify()} im \textit{Controller} führt das \textit{Model} die Aktion \textit{notifyObersvers()} aus. Die Methode \textit{update()} der \textit{MainView} ruft die entsprechenden \textit{update()} der daraufliegenden Panel auf. Die Methode \textit{update()} der Panel holen sich die benötigte Information via Getter-Methoden vom Model und bringen sie zur Darstellung.\\
\\
\subsection{Neues Ersatzschaltbild erstellen} \label{Neues Ersatzschaltbild erstellen}
Nach dem Einlesen des Datenfiles kann nun ein Ersatzschaltbild erstellt werden. Durch das Betätigen des \textit{JButton}s "{}New Model"{} wird ein \textit{JDialog} in der Methode \textit{buildNewModelWindow()} der Klasse \textit{NewModelWindow} erstellt mit den benötigten Textfeldern und Dialogboxen. Der Benutzer ändert nichts an den Einstellungen, womit er die Automatische Generierung eines Ersatzschaltbildes wünscht. Mit der Taste "{}Generate"{} wird in \textit{actionPerformed()} von \textit{NewModelWindow} die gewählten Einstellungen in der Methode \textit{parseInput()} eingelesen und in einer Instanz der Klasse \textit{MCOptions} abgespeichert. Diese Instanz von \textit{MCOptions} wird dann an den \textit{Controller} mit der Methode \textit{createEqCircuit()} übergeben. Er gibt der \textit{MainView} den Befehl zum erstellen eines leeren \textit{ModelLabelPanel}, dies geschieht in der Methode \textit{setupEqCircuitView()} vom \textit{NavPanel}. Nach dieser Aktion ruf der \textit{Controller} die Methode \textit{createEqCircuit()} des \textit{Model}s auf und übergibt dabei die \textit{MCOptions} welche vom \textit{NewModelWindow} ersetllt wurden. Das \textit{Model} erstellt eine neue Instanz der Klasse \textit{MCWorker} und setzt die \textit{MCOptions} mit der Methode \textit{setMCOptions()}. Da der \textit{MCWorker} von der Klasse \textit{Thread} erbt, kann dieser Thread nun mit der Methode \textit{start()} gestartet werden. Die Aktionen im Haupt-Thread sind nun abgeschlossen und das GUI bleibt aktiv, während der \textit{MCWorker} die Berechnungen übernimmt.\\
\\
\subsection{Berechnung}
Die Berechnungen werden in der Methode \textit{run()} der Klasse \textit{MCWorker} ausgeführt. Darin werden zuerst alle benötigten Daten vom \textit{Model} über Getter-Methoden lokal abgespeichert. Die Berechnungen werden dann mithilfe von statischen Methoden in den verschiedenen Klassen des Packages \textit{ezrlc.ModelCalculation} ausgefhürt. Im Extremfall müssen sechs Ersatzschaltbilder optimiert werden. Damit dies schnell erfolgt werden diese Optimizer in seperaten Threads ausgeführt. Dies geschieht in der Methode \textit{run()} der Klasse \textit{MCEqCircuit} da diese Klasse das Interface \textit{Runnable} implementiert. Die benötigten Threads werden in \textit{run()} vom \textit{MCWorker} erstellt. 
\\
Sobald alle Berechnungen fertiggestellt wurden, ruft der \textit{MCWorker} in der Methode \textit{success()} die Methode \textit{mcWorkerSuccess()} vom \textit{Model} auf und übergibt das berechnete Ersatzschaltbild der Klasse \textit{MCEqCircuit}. Das Model speichert die Instanz von \textit{MCEqCircuit} in einer \textit{ArrayList} und ruft \textit{notifyObservers()} auf. Dies triggert den Mechanismum wie er bei \ref{Neues Ersatzschaltbild erstellen} bereits erleutert ist. Dabei wird im \textit{NavPanel} in der Methode \textit{updateNewModelLabel()} die Liste mit den Ersatzschaltbilder aktualisiert. Dazu wird im Model mit den nötigen Getter-Methoden die Instanz des generierten \textit{MCEqCircuit} an das \textit{ModelLabelPanel} in der Methode \textit{build()} weitergeleited. Im \textit{ModelLabelPanel} wird das korrekte Bild und die berechneten Parameter des neuen Ersatzschaltbildes erstellt und angezeigt. Somit ist die Erstellung eines neuen Ersatzschaltbildes vollendet.\\
\\
\subsection{Neuen Graph erstellen}
Nun will der Benutzer die berechneten Daten visualisieren. Dazu klickt er auf die Schaltfläche "{}New Graph"{} im \textit{NavPanel}. In der Methode \textit{actionPerformed()} vom \textit{NavPanel} wird \textit{buildDialog()} vom \textit{GraphWindow} aufgerufen. Der Dialog zum erstellen eines neuen Graphen erscheint und der Benutzer kann zwischen Rectangular Plot und Smithchart unterscheiden. Das \textit{GraphWindow} ruft nach betätigung der "{}OK"{}-Taste die Methode \textit{addGraph()} in der \textit{MainView} auf und übergibt als Option mit ob ein Rectangular Plot oder eine Smithchart erstellt werden soll. Die \textit{MainView} ruf im \textit{WorkPanel} die Methode \textit{addGraph()} auf, welche eine neue \textit{Figure} erstellt mit den gewünschten Einstellungen. Ausserdem wird der Anzeigemodus des \textit{WorkPanel}s von Overview auf Figure umgestellt. \\
\\
\subsection{Neue Messung darstellung}
Nachdem der Graph erstellt wurde kann der Benutzer Messungen zum Plot hinzufügen. In diesem Beispiel wird davon ausgegangen, dass ein Rectangular Plot erstellt wurde. Nach dem Betätigen der "{}Add Measurement"{}-Taste wird in der \textit{Figure} die Methode \textit{actionPerformed()} aufgerufen. In einer Instanz von \textit{RectPlotAddMeasurementWindow} wird der Dateiname und eine Liste der generierten Modelle gesetzt. Die nötigen Daten werden vom \textit{Controller} über Getter-Methoden bezogen. Mit der Methode \textit{show()} der Klasse \textit{RectPlotAddMeasurementWindow} wird der Dialog angezeigt und der Benutzer kann auswählen, welche Daten er anzeigen möchte. Nach dem Betätigen der "{}OK"{}-Taste im Add Measurement dialog, liest die Methode \textit{parse()} im \textit{RectPlotAddMeasurementWindow} die Benutzereingaben ein, speichert sie in einer Instanz von \textit{RectPlotNewMeasurement} und ruft die Methode \textit{addNewMeasurement()} in der \textit{Figure} auf. Die \textit{Figure} ruft die Methode \textit{createDataset()} im \textit{Controller} auf und übergiebt die Einstellungen \textit{RectPlotNewMeasurement}. Der \textit{Controller} leitet diesen Befehl wiederum weiter an das \textit{Model}. Das \textit{Model} erstellt eine neue Instanz von \textit{DataSet} in der Methode \textit{buildDataSetRaw()} und speichert sie in einer \textit{ArrayList}. Zudem wird eine ID erstellt, welche verwendet wird um auf dieses \textit{DataSet} zuzugreifen. Die \textit{Figure} speichert diese ID und übergibt sie dem \textit{RectangularPlot} mit der Methode \textit{addDataSet()}. Die \textit{Figure} ruft die Methode \textit{manualNotify()} im \textit{Controller} auf um ein \textit{notifyObservers()} des \textit{Model}s zu erzwingen. Dabei wird in der \textit{update()} Methode vom \textit{RectangularPlot} das \textit{DataSet} geplottet.\\
\\
\subsection{Parameter Tuner}
Ein spezielles Feature dieser Software ist der Tuner: Die Bauteilwerte eines erstellten Ersatzschaltbildes können per Mausrad verändert werden, wobei umgehend alle Plots, die mit diesem Ersatzschaltbild zusammenhängen, aktualisiert werden. Um eine solche Änderung wahrzunehmen, implementiert Klasse \textit{ModelLabelPanel} (welches die Parameter des Ersatzschaltbildes anzeigt) einen \textit{DocumentListener}, welcher mit den \textit{JEngineerField}-Textfeldern verbunden ist. Wenn also eine Änderung der Werte erfolgt (durch Mausrad oder Eingabe) wird die Methode \textit{insertUpdate()} in \textit{ModelLabelPanel} aufgerufen. Sie ruft die Methode \textit{tuner()} auf, welche die neuen Werte einliest und an den \textit{Controller} mit der Methode \textit{updateEqcParams()} weitergibt. Der \textit{Controler} ruft die Methode \textit{updateEqcParams} im \textit{Model} auf, welche alle \textit{DataSet}s aktualisiert. Dies geschieht in der Methode \textit{updateDataset()} vom \textit{Model}. Wenn das \textit{DataSet} existiert und nicht von dem Datenfile generiert wurde, wird mit der Methode \textit{buildDataSetRaw()} ein neues \textit{DataSet} erstellt und in der Liste das alte überschrieben. Über das Notify Observers Prinzip wird das GUI aktualisiert und der Benutzer sieht die Änderungen.


\end{document}
